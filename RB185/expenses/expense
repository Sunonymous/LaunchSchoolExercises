#! /usr/bin/env ruby

# frozen_string_literal: true

require 'pg'

# Constants
COMMANDS = %w[add clear list delete search].freeze
CMD_INFO = {
  'add'    => '<AMOUNT> <MEMO> [<DATE>] - record a new expense. <DATE> is optional',
  'clear'  => 'delete all expenses',
  'list'   => 'list all expenses',
  'delete' => '<NUMBER> - remove expenses with id <NUMBER>',
  'search' => '<QUERY> - list expenses with <QUERY> in the memo'
}.freeze

# Exp_tup is a hash containing keys 'id', 'amount', 'memo', and 'created_on'
def display_expense(exp_tup)
  id = exp_tup['id'].center(3)
  date = exp_tup['created_on'].split.first.center(12)
  amount = exp_tup['amount'].rjust(14)
  memo = exp_tup['memo']
  puts "#{id}|#{date}|#{amount}| #{memo}"
end

def display_key
  id = 'id'.center(3)
  date = 'created_on'.split.first.center(12)
  amount = 'amount'.rjust(14)
  memo = 'memo'
  puts "#{id}|#{date}|#{amount}| #{memo}"
end

def get_length_of_longest_memo(tuple_array)
  tuple_array.map { |tup| tup['memo'].size }.max
end

def list_all_expenses
  query_all_expenses = 'SELECT * FROM expenses ORDER BY created_on;'
  expenses = DB.exec(query_all_expenses)
  puts "All Expenses\n\n"
  display_key
  puts '-' * (33 + get_length_of_longest_memo(expenses))
  expenses.each do |exp_tup|
    display_expense(exp_tup)
  end
end

def display_commands
  puts "Commands:\n\n"
  COMMANDS.each do |cmd|
    puts "#{cmd} #{CMD_INFO[cmd]}"
  end
end

def abort_action
  puts "Invalid input.\n\n"
  display_commands
end

# Connect to database
DB = PG.connect(dbname: 'expense_tracker')

# Check arguments passed to program
puts "An expense recording system.\n\n"
if ARGV.empty?
  display_commands
else
  case ARGV.first
  when 'add'    then 0
  when 'clear'  then 0
  when 'list'   then list_all_expenses
  when 'delete' then 0
  when 'search' then 0
  else abort_action
  end
end
